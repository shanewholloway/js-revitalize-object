'use strict';const root_obj={},root_list=[],ObjMap='undefined'==typeof WeakMap?Map:WeakMap;class Revitalization extends Function{constructor(){throw new Error('Use the static .create() instead of new')}static create(a){function b(){return e.register.apply(e,arguments)}b.token=a||'\u039E';const c=new Map,d=new ObjMap,e=Object.setPrototypeOf(b,this.prototype);return Object.defineProperties(e,{lookupReviver:{value:c.get.bind(c)},lookupPreserver:{value:d.get.bind(d)},_setReviver:{value:function(a){return c.set(a.kind,a),{alias(...b){for(const d of b)d&&c.set(d,a);return this},match(...b){for(const c of b)null!=c&&d.set(c,a);return this}}}}}),e.initRegistery(root_obj,root_list),e}initRegistery(a,b){this.register({kind:'{root}',revive(a,b){Object.assign(a,b.body)}}).match(a),this.register({kind:'[root]',preserve(a){return{_:a.slice()}},init(){return[]},revive(a,b){a.push.apply(a,b.body._)}}).match(b)}register(a){if('kind'in a&&a.revive)return this.registerReviver(a);let b;if(void 0!==a.prototype&&(b=a.prototype[this.token],void 0!==b)){if('function'==typeof b&&(b=b.call(a.prototype,this),null==b))return;if('string'==typeof b)return this.registerClass(b,a)}if(b=a[this.token],void 0!==b){if('function'==typeof b&&(b=b.call(a,this),null==b))return;if('string'==typeof b)return this.registerProto(b,a.prototype||a).match(a)}throw new TypeError(`Unrecognized revitalization registration`)}registerReviver(a){{const b=a.kind;if('string'!=typeof b&&!0!==b&&!1!==b&&null!==b)throw new TypeError(`"kind" must be a string`);if(a.init&&'function'!=typeof a.init)throw new TypeError('"init" must be a function');if('function'!=typeof a.revive)throw new TypeError('"revive" must be a function');if(a.preserve&&'function'!=typeof a.preserve)throw new TypeError('"preserve" must be a function if provided')}return this._setReviver(a)}registerClass(a,b){return this.registerReviver({kind:a,revive(a,c){a=Object.assign(a,c.body),Object.setPrototypeOf(a,b.prototype)}}).match(b,b.prototype)}registerProto(a,b){return this.registerReviver({kind:a,revive(a,c){a=Object.assign(a,c.body),Object.setPrototypeOf(a,b)}}).match(b)}decode(a,b){null==b&&(b={});const c=this.token,d=this.lookupReviver,e=[],f=new Map;JSON.parse(a,function(a,g){if(c===a){if('number'==typeof g);else if(Array.isArray(g)){delete this[c];const[a,h]=g,i=d(a);if(void 0===i)throw new ReviverNotFound(`Missing registered reviver for kind "${a}"`);const j={kind:a,oid:h,reviver:i,body:this};j.obj=i.init?i.init(j,b):Object.create(null),f.set(h,j),e.push(j)}return}return g});const g=new ObjMap;JSON.parse(a,function(a,b){if(c===a){if('number'==typeof b)g.set(this,f.get(b).obj);else if(Array.isArray(b)){const a=f.get(b[1]);a.body=this,g.set(this,a.obj)}return}if(null===b||'object'!=typeof b)return b;const d=g.get(b);return void 0===d?b:d});const h={},i=Promise.resolve().then(()=>e.reverse().map((a)=>{return a.evts=h,a.reviver.revive(a.obj,a,b)}));return h.started=i.then((a)=>a.length),h.finished=i.then((a)=>Promise.all(a).then((a)=>a.length)),h.done=h.finished.then(()=>{const a=f.get(0);if(void 0===a)return;const{obj:b,promise:c}=a;return void 0===c?b:c.then((a)=>void 0===a?b:a)}),h.done}encode(a,b){const c=[],d=this.encodeObjects(a,b,(a,b)=>{c[b.oid]=b.content}),e=JSON.stringify(`${this.token}refs`);return d.then(()=>`{${e}: [\n  ${c.join(',\n  ')} ]}\n`)}encodeObjects(a,b,c){function d(){if(0===i.length)return Promise.resolve();const a=[];for(;0!==i.length;){const b=i.shift(),d=b.oid;a.push(b.then((a)=>{const b=JSON.stringify(a,e);return c(null,{oid:d,body:a,content:b})}).catch((a)=>c(a)))}return Promise.all(a).then(d)}function e(c,d){const e=this[c];if(null===d||'object'!=typeof e)return d;const k=j.get(e);if(void 0!==k)return k;let l=h(e);if(void 0===l){if(a!==e)return d;l=g(Array.isArray(d)?root_list:root_obj)}const m=j.size,n={[f]:m};j.set(e,n);const o={[f]:[l.kind,m]},p=Promise.resolve(l.preserve?l.preserve(d,e,b):d).then((a)=>Object.assign(o,a));return p.oid=m,i.push(p),n}'function'==typeof b?(c=b,b={}):null==b&&(b={});const f=this.token,g=this.lookupPreserver,h=this._boundFindPreserveForObj(),i=[],j=new Map;return JSON.stringify(a,e),d()}_boundFindPreserveForObj(){const a=this.lookupPreserver;return function(b){let c=a(b);if(void 0!==c)return c;if(c=a(b.constructor),void 0!==c)return c;for(let c,d=b;null!==(d=Object.getPrototypeOf(d));)if(c=a(d),void 0!==c)return c}}}class ReviverNotFound extends Error{}const createRegistry=Revitalization.create.bind(Revitalization);module.exports=exports=createRegistry(),Object.assign(exports,{Revitalization,ReviverNotFound,createRegistry,create:createRegistry});

//# sourceMappingURL=index.min.js.map