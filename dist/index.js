'use strict';

const root_obj = {},
      root_list = [];
const ObjMap = 'undefined' !== typeof WeakMap ? WeakMap : Map;

class Revitalization extends Function {
  constructor() {
    throw new Error('Use the static .create() instead of new');
  }

  static create(token_p) {
    register.token = token_p || '\u039E'; // 'Îž'

    const lutRevive = new Map();
    const lutPreserve = new ObjMap();

    const self = Object.setPrototypeOf(register, this.prototype);
    Object.defineProperties(self, { lookupReviver: { value: lutRevive.get.bind(lutRevive) }, lookupPreserver: { value: lutPreserve.get.bind(lutPreserve) }, _setReviver: { value: _setReviver } });

    self.initRegistery(root_obj, root_list);
    return self;

    function register() {
      return self.register.apply(self, arguments);
    }

    function _setReviver(entry, kinds, matchers) {
      lutRevive.set(entry.kind, entry);
      return {
        alias(...kinds) {
          for (const each of kinds) {
            if (each) {
              lutRevive.set(each, entry);
            }
          }
          return this;
        }, match(...matchers) {
          for (const each of matchers) {
            if (null != each) {
              lutPreserve.set(each, entry);
            }
          }
          return this;
        } };
    }
  }

  initRegistery(root_obj, root_list) {
    this.register({ kind: '{root}',
      revive(obj, entry) {
        Object.assign(obj, entry.body);
      } }).match(root_obj);

    this.register({ kind: '[root]',
      preserve(rootList) {
        return { _: rootList.slice() };
      }, init(entry) {
        return [];
      }, revive(rootList, entry) {
        rootList.push.apply(rootList, entry.body._);
      } }).match(root_list);
  }

  register(revitalizer) {
    if ('kind' in revitalizer && revitalizer.revive) {
      return this.registerReviver(revitalizer);
    }

    let tgt;
    if (undefined !== revitalizer.prototype) {
      tgt = revitalizer.prototype[this.token];
      if (undefined !== tgt) {
        if ('function' === typeof tgt) {
          tgt = tgt.call(revitalizer.prototype, this);
          if (null == tgt) {
            return;
          }
        }
        if ('string' === typeof tgt) {
          return this.registerClass(tgt, revitalizer);
        }
      }
    }

    tgt = revitalizer[this.token];
    if (undefined !== tgt) {
      if ('function' === typeof tgt) {
        tgt = tgt.call(revitalizer, this);
        if (null == tgt) {
          return;
        }
      }
      if ('string' === typeof tgt) {
        return this.registerProto(tgt, revitalizer.prototype || revitalizer).match(revitalizer);
      }
    }

    throw new TypeError(`Unrecognized revitalization registration`);
  }

  registerReviver(entry) {
    {
      const kind = entry.kind;
      if ('string' !== typeof kind && true !== kind && false !== kind && null !== kind) {
        throw new TypeError(`"kind" must be a string`);
      }

      if (entry.init && 'function' !== typeof entry.init) {
        throw new TypeError('"init" must be a function');
      }

      if ('function' !== typeof entry.revive) {
        throw new TypeError('"revive" must be a function');
      }

      if (entry.preserve && 'function' !== typeof entry.preserve) {
        throw new TypeError('"preserve" must be a function if provided');
      }
    }

    return this._setReviver(entry);
  }

  registerClass(kind, klass) {
    return this.registerReviver({ kind,
      revive(obj, entry) {
        obj = Object.assign(obj, entry.body);
        Object.setPrototypeOf(obj, klass.prototype);
      } }).match(klass, klass.prototype);
  }

  registerProto(kind, proto) {
    return this.registerReviver({ kind,
      revive(obj, entry) {
        obj = Object.assign(obj, entry.body);
        Object.setPrototypeOf(obj, proto);
      } }).match(proto);
  }

  decode(aString, ctx) {
    if (null === aString) {
      return null; // JSON.parse(null) returns null; keep with convention
    }if (null == ctx) {
      ctx = {};
    }
    const token = this.token,
          lookupReviver = this.lookupReviver;

    const queue = [],
          byOid = new Map();
    JSON.parse(aString, _json_create);

    const refs = new ObjMap();
    JSON.parse(aString, _json_restore);

    const evts = {};
    const _start = Promise.resolve().then(() => queue.reverse().map(entry => {
      entry.evts = evts;
      return entry.reviver.revive(entry.obj, entry, ctx);
    }));

    evts.started = _start.then(lst => lst.length);
    evts.finished = _start.then(lst => Promise.all(lst).then(lst => lst.length));

    evts.done = evts.finished.then(() => {
      const root = byOid.get(0);
      if (null == root) {
        return;
      }

      const { obj, promise } = root;
      return undefined === promise ? obj : promise.then(ans => ans !== undefined ? ans : obj);
    });
    return evts.done;

    function _json_create(key, value) {
      if (token === key) {
        if ('number' === typeof value) {} else if (Array.isArray(value)) {
          delete this[token];

          const [kind, oid] = value;
          const reviver = lookupReviver(kind);
          if (undefined === reviver) {
            throw new ReviverNotFound(`Missing registered reviver for kind "${kind}"`);
          }

          const entry = { kind, oid, reviver, body: this };

          entry.obj = reviver.init ? reviver.init(entry, ctx) : Object.create(null);

          byOid.set(oid, entry);
          queue.push(entry);
        }
        return;
      }

      return value;
    }

    function _json_restore(key, value) {
      if (token === key) {
        if ('number' === typeof value) {
          refs.set(this, byOid.get(value).obj);
        } else if (Array.isArray(value)) {
          const entry = byOid.get(value[1]);
          entry.body = this;
          refs.set(this, entry.obj);
        }
        return;
      } else if (null === value || 'object' !== typeof value) {
        return value;
      }

      const ans = refs.get(value);
      return ans !== undefined ? ans : value;
    }
  }

  encode(anObject, ctx) {
    const refs = [];
    const promise = this.encodeObjects(anObject, ctx, (err, entry) => {
      refs[entry.oid] = entry.content;
    });

    const key = JSON.stringify(`${this.token}refs`);
    return promise.then(() => `{${key}: [\n  ${refs.join(',\n  ')} ]}\n`);
  }

  encodeObjects(anObject, ctx, callback) {
    if ('function' === typeof ctx) {
      callback = ctx;ctx = {};
    } else if (null == ctx) {
      ctx = {};
    }

    const token = this.token,
          lookupPreserver = this.lookupPreserver,
          findPreserver = this._boundFindPreserveForObj();

    const queue = [],
          lookup = new Map();
    JSON.stringify(anObject, _json_replacer);

    return _encodeQueue();

    function _encodeQueue() {
      if (0 === queue.length) {
        return Promise.resolve();
      }

      const promises = [];
      while (0 !== queue.length) {
        const tip = queue.shift(),
              oid = tip.oid;
        promises.push(tip.then(body => {
          const content = JSON.stringify(body, _json_replacer);
          return callback(null, { oid, body, content });
        }).catch(err => callback(err)));
      }

      return Promise.all(promises).then(_encodeQueue);
    }

    function _json_replacer(key, dstValue) {
      // srcValue !== dstValue for objects with .toJSON() methods
      const srcValue = this[key];

      if (dstValue === null || 'object' !== typeof srcValue) {
        return dstValue;
      }

      const prev = lookup.get(srcValue);
      if (undefined !== prev) {
        return prev; // already serialized -- reference existing item
      }let entry = findPreserver(srcValue);
      if (undefined === entry) {
        // not a "special" preserved item
        if (anObject !== srcValue) {
          return dstValue; // so serialize normally
        }
        // but it is the root, so store at oid 0
        entry = lookupPreserver(Array.isArray(dstValue) ? root_list : root_obj);
      }

      // register id for object and return a JSON serializable version
      const oid = lookup.size;
      const ref = { [token]: oid };
      lookup.set(srcValue, ref

      // transform live object into preserved form
      );const body = { [token]: [entry.kind, oid] };
      const promise = Promise.resolve(entry.preserve ? entry.preserve(dstValue, srcValue, ctx) : dstValue).then(attrs => Object.assign(body, attrs));

      promise.oid = oid;
      queue.push(promise);
      return ref;
    }
  }

  _boundFindPreserveForObj() {
    const lookupPreserver = this.lookupPreserver;
    return function (obj) {
      let entry = lookupPreserver(obj);
      if (undefined !== entry) {
        return entry;
      }

      entry = lookupPreserver(obj.constructor);
      if (undefined !== entry) {
        return entry;
      }

      let proto = obj;
      while (null !== (proto = Object.getPrototypeOf(proto))) {
        let entry = lookupPreserver(proto);
        if (undefined !== entry) {
          return entry;
        }
      }
    };
  }
}

class ReviverNotFound extends Error {}

const createRegistry = Revitalization.create.bind(Revitalization);

module.exports = exports = createRegistry();
Object.assign(exports, { Revitalization, ReviverNotFound,
  createRegistry, create: createRegistry });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2NvZGUvaW5kZXguanMiXSwibmFtZXMiOlsicm9vdF9vYmoiLCJyb290X2xpc3QiLCJPYmpNYXAiLCJXZWFrTWFwIiwiTWFwIiwiUmV2aXRhbGl6YXRpb24iLCJGdW5jdGlvbiIsImNvbnN0cnVjdG9yIiwiRXJyb3IiLCJjcmVhdGUiLCJ0b2tlbl9wIiwicmVnaXN0ZXIiLCJ0b2tlbiIsImx1dFJldml2ZSIsImx1dFByZXNlcnZlIiwic2VsZiIsIk9iamVjdCIsInNldFByb3RvdHlwZU9mIiwicHJvdG90eXBlIiwiZGVmaW5lUHJvcGVydGllcyIsImxvb2t1cFJldml2ZXIiLCJ2YWx1ZSIsImdldCIsImJpbmQiLCJsb29rdXBQcmVzZXJ2ZXIiLCJfc2V0UmV2aXZlciIsImluaXRSZWdpc3RlcnkiLCJhcHBseSIsImFyZ3VtZW50cyIsImVudHJ5Iiwia2luZHMiLCJtYXRjaGVycyIsInNldCIsImtpbmQiLCJhbGlhcyIsImVhY2giLCJtYXRjaCIsInJldml2ZSIsIm9iaiIsImFzc2lnbiIsImJvZHkiLCJwcmVzZXJ2ZSIsInJvb3RMaXN0IiwiXyIsInNsaWNlIiwiaW5pdCIsInB1c2giLCJyZXZpdGFsaXplciIsInJlZ2lzdGVyUmV2aXZlciIsInRndCIsInVuZGVmaW5lZCIsImNhbGwiLCJyZWdpc3RlckNsYXNzIiwicmVnaXN0ZXJQcm90byIsIlR5cGVFcnJvciIsImtsYXNzIiwicHJvdG8iLCJkZWNvZGUiLCJhU3RyaW5nIiwiY3R4IiwicXVldWUiLCJieU9pZCIsIkpTT04iLCJwYXJzZSIsIl9qc29uX2NyZWF0ZSIsInJlZnMiLCJfanNvbl9yZXN0b3JlIiwiZXZ0cyIsIl9zdGFydCIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsInJldmVyc2UiLCJtYXAiLCJyZXZpdmVyIiwic3RhcnRlZCIsImxzdCIsImxlbmd0aCIsImZpbmlzaGVkIiwiYWxsIiwiZG9uZSIsInJvb3QiLCJwcm9taXNlIiwiYW5zIiwia2V5IiwiQXJyYXkiLCJpc0FycmF5Iiwib2lkIiwiUmV2aXZlck5vdEZvdW5kIiwiZW5jb2RlIiwiYW5PYmplY3QiLCJlbmNvZGVPYmplY3RzIiwiZXJyIiwiY29udGVudCIsInN0cmluZ2lmeSIsImpvaW4iLCJjYWxsYmFjayIsImZpbmRQcmVzZXJ2ZXIiLCJfYm91bmRGaW5kUHJlc2VydmVGb3JPYmoiLCJsb29rdXAiLCJfanNvbl9yZXBsYWNlciIsIl9lbmNvZGVRdWV1ZSIsInByb21pc2VzIiwidGlwIiwic2hpZnQiLCJjYXRjaCIsImRzdFZhbHVlIiwic3JjVmFsdWUiLCJwcmV2Iiwic2l6ZSIsInJlZiIsImF0dHJzIiwiZ2V0UHJvdG90eXBlT2YiLCJjcmVhdGVSZWdpc3RyeSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7O0FBQUEsTUFBTUEsV0FBVyxFQUFqQjtBQUFBLE1BQXFCQyxZQUFZLEVBQWpDO0FBQ0EsTUFBTUMsU0FBUyxnQkFBZ0IsT0FBT0MsT0FBdkIsR0FBaUNBLE9BQWpDLEdBQTJDQyxHQUExRDs7QUFFQSxNQUFNQyxjQUFOLFNBQTZCQyxRQUE3QixDQUFzQztBQUNwQ0MsZ0JBQWM7QUFDWixVQUFNLElBQUlDLEtBQUosQ0FBVSx5Q0FBVixDQUFOO0FBQTBEOztBQUU1RCxTQUFPQyxNQUFQLENBQWNDLE9BQWQsRUFBdUI7QUFDckJDLGFBQVNDLEtBQVQsR0FBaUJGLFdBQVcsUUFBNUIsQ0FEcUIsQ0FDZ0I7O0FBRXJDLFVBQU1HLFlBQVUsSUFBSVQsR0FBSixFQUFoQjtBQUNBLFVBQU1VLGNBQVksSUFBSVosTUFBSixFQUFsQjs7QUFFQSxVQUFNYSxPQUFPQyxPQUFPQyxjQUFQLENBQXNCTixRQUF0QixFQUFnQyxLQUFLTyxTQUFyQyxDQUFiO0FBQ0FGLFdBQU9HLGdCQUFQLENBQTBCSixJQUExQixFQUNFLEVBQUlLLGVBQWUsRUFBSUMsT0FBT1IsVUFBVVMsR0FBVixDQUFjQyxJQUFkLENBQW1CVixTQUFuQixDQUFYLEVBQW5CLEVBQ0lXLGlCQUFpQixFQUFJSCxPQUFPUCxZQUFZUSxHQUFaLENB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QWM7QUFDbkIsVUFBSVQsUUFBUUwsZ0JBQWdCYyxHQUFoQixDQUFaO0FBQ0EsVUFBR1ksY0FBY3JCLEtBQWpCLEVBQXlCO0FBQ3ZCLGVBQU9BLEtBQVA7QUFBWTs7QUFFZEEsY0FBUUwsZ0JBQWdCYyxJQUFJL0IsV0FBcEIsQ0FBUjtBQUNBLFVBQUcyQyxjQUFjckIsS0FBakIsRUFBeUI7QUFDdkIsZUFBT0EsS0FBUDtBQUFZOztBQUVkLFVBQUkyQixRQUFRbEIsR0FBWjtBQUNBLGFBQU0sVUFBV2tCLFFBQVF4QyxPQUFPZ0csY0FBUCxDQUFzQnhELEtBQXRCLENBQW5CLENBQU4sRUFBd0Q7QUFDdEQsWUFBSTNCLFFBQVFMLGdCQUFnQmdDLEtBQWhCLENBQVo7QUFDQSxZQUFHTixjQUFjckIsS0FBakIsRUFBeUI7QUFDdkIsaUJBQU9BLEtBQVA7QUFBWTtBQUFBO0FBQUEsS0FibEI7QUFha0I7QUFsUmdCOztBQXFSdEMsTUFBTTJELGVBQU4sU0FBOEJoRixLQUE5QixDQUFvQzs7QUFFcEMsTUFBTXlHLGlCQUFpQjVHLGVBQWVJLE1BQWYsQ0FBc0JjLElBQXRCLENBQTJCbEIsY0FBM0IsQ0FBdkI7O0FBRUE2RyxPQUFPQyxPQUFQLEdBQWlCQSxVQUFVRixnQkFBM0I7QUFDQWpHLE9BQU91QixNQUFQLENBQWdCNEUsT0FBaEIsRUFDSSxFQUFJOUcsY0FBSixFQUFvQm1GLGVBQXBCO0FBQ0l5QixnQkFESixFQUNvQnhHLFFBQVF3RyxjQUQ1QixFQURKIiwiZmlsZSI6ImluZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgcm9vdF9vYmogPSB7fSwgcm9vdF9saXN0ID0gW11cbmNvbnN0IE9iak1hcCA9ICd1bmRlZmluZWQnICE9PSB0eXBlb2YgV2Vha01hcCA/IFdlYWtNYXAgOiBNYXBcblxuY2xhc3MgUmV2aXRhbGl6YXRpb24gZXh0ZW5kcyBGdW5jdGlvbiA6OlxuICBjb25zdHJ1Y3RvcigpIDo6XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVc2UgdGhlIHN0YXRpYyAuY3JlYXRlKCkgaW5zdGVhZCBvZiBuZXcnKVxuXG4gIHN0YXRpYyBjcmVhdGUodG9rZW5fcCkgOjpcbiAgICByZWdpc3Rlci50b2tlbiA9IHRva2VuX3AgfHwgJ1xcdTAzOUUnIC8vICfOnidcblxuICAgIGNvbnN0IGx1dFJldml2ZT1uZXcgTWFwKClcbiAgICBjb25zdCBsdXRQcmVzZXJ2ZT1uZXcgT2JqTWFwKClcblxuICAgIGNvbnN0IHNlbGYgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YocmVnaXN0ZXIsIHRoaXMucHJvdG90eXBlKVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIEAgc2VsZixcbiAgICAgIEB7fSBsb29rdXBSZXZpdmVyOiBAe30gdmFsdWU6IGx1dFJldml2ZS5nZXQuYmluZChsdXRSZXZpdmUpXG4gICAgICAgICwgbG9va3VwUHJlc2VydmVyOiBAe30gdmFsdWU6IGx1dFByZXNlcnZlLmdldC5iaW5kKGx1dFByZXNlcnZlKVxuICAgICAgICAsIF9zZXRSZXZpdmVyOiBAe30gdmFsdWU6IF9zZXRSZXZpdmVyXG5cblxuICAgIHNlbGYuaW5pdFJlZ2lzdGVyeShyb290X29iaiwgcm9vdF9saXN0KVxuICAgIHJldHVybiBzZWxmXG5cbiAgICBmdW5jdGlvbiByZWdpc3RlcigpIDo6XG4gICAgICByZXR1cm4gc2VsZi5yZWdpc3Rlci5hcHBseShzZWxmLCBhcmd1bWVudHMpXG5cbiAgICBmdW5jdGlvbiBfc2V0UmV2aXZlcihlbnRyeSwga2luZHMsIG1hdGNoZXJzKSA6OlxuICAgICAgbHV0UmV2aXZlLnNldChlbnRyeS5raW5kLCBlbnRyeSlcbiAgICAgIHJldHVybiA6OlxuICAgICAgICAgIGFsaWFzKC4uLmtpbmRzKSA6OlxuICAgICAgICAgICAgZm9yIGNvbnN0IGVhY2ggb2Yga2luZHMgOjpcbiAgICAgICAgICAgICAgaWYgZWFjaCA6OiBsdXRSZXZpdmUuc2V0KGVhY2gsIGVudHJ5KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgLCBtYXRjaCguLi5tYXRjaGVycykgOjpcbiAgICAgICAgICAgIGZvciBjb25zdCBlYWNoIG9mIG1hdGNoZXJzIDo6XG4gICAgICAgICAgICAgIGlmIG51bGwgIT0gZWFjaCA6OiBsdXRQcmVzZXJ2ZS5zZXQoZWFjaCwgZW50cnkpXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuXG5cbiAgaW5pdFJlZ2lzdGVyeShyb290X29iaiwgcm9vdF9saXN0KSA6OlxuICAgIHRoaXNcbiAgICAgIC5yZWdpc3RlciBAOiBraW5kOiAne3Jvb3R9J1xuICAgICAgICAsIHJldml2ZShvYmosIGVudHJ5KSA6OiBPYmplY3QuYXNzaWduKG9iaiwgZW50cnkuYm9keSlcbiAgICAgIC5tYXRjaCBAIHJvb3Rfb2JqXG5cbiAgICB0aGlzXG4gICAgICAucmVnaXN0ZXIgQDoga2luZDogJ1tyb290XSdcbiAgICAgICAgLCBwcmVzZXJ2ZShyb290TGlzdCkgOjogcmV0dXJuIEB7fSBfOiByb290TGlzdC5zbGljZSgpXG4gICAgICAgICwgaW5pdChlbnRyeSkgOjogcmV0dXJuIFtdXG4gICAgICAgICwgcmV2aXZlKHJvb3RMaXN0LCBlbnRyeSkgOjpcbiAgICAgICAgICAgIHJvb3RMaXN0LnB1c2guYXBwbHkocm9vdExpc3QsIGVudHJ5LmJvZHkuXylcbiAgICAgIC5tYXRjaCBAIHJvb3RfbGlzdFxuXG4gIHJlZ2lzdGVyKHJldml0YWxpemVyKSA6OlxuICAgIGlmICdraW5kJyBpbiByZXZpdGFsaXplciAmJiByZXZpdGFsaXplci5yZXZpdmUgOjpcbiAgICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyUmV2aXZlcihyZXZpdGFsaXplcilcblxuICAgIGxldCB0Z3RcbiAgICBpZiB1bmRlZmluZWQgIT09IHJldml0YWxpemVyLnByb3RvdHlwZSA6OlxuICAgICAgdGd0ID0gcmV2aXRhbGl6ZXIucHJvdG90eXBlW3RoaXMudG9rZW5dXG4gICAgICBpZiB1bmRlZmluZWQgIT09IHRndCA6OlxuICAgICAgICBpZiAnZnVuY3Rpb24nID09PSB0eXBlb2YgdGd0IDo6XG4gICAgICAgICAgdGd0ID0gdGd0LmNhbGwocmV2aXRhbGl6ZXIucHJvdG90eXBlLCB0aGlzKVxuICAgICAgICAgIGlmIG51bGwgPT0gdGd0IDo6IHJldHVyblxuICAgICAgICBpZiAnc3RyaW5nJyA9PT0gdHlwZW9mIHRndCA6OlxuICAgICAgICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyQ2xhc3ModGd0LCByZXZpdGFsaXplcilcblxuICAgIHRndCA9IHJldml0YWxpemVyW3RoaXMudG9rZW5dXG4gICAgaWYgdW5kZWZpbmVkICE9PSB0Z3QgOjpcbiAgICAgIGlmICdmdW5jdGlvbicgPT09IHR5cGVvZiB0Z3QgOjpcbiAgICAgICAgdGd0ID0gdGd0LmNhbGwocmV2aXRhbGl6ZXIsIHRoaXMpXG4gICAgICAgIGlmIG51bGwgPT0gdGd0IDo6IHJldHVyblxuICAgICAgaWYgJ3N0cmluZycgPT09IHR5cGVvZiB0Z3QgOjpcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJQcm90byh0Z3QsIHJldml0YWxpemVyLnByb3RvdHlwZSB8fCByZXZpdGFsaXplcilcbiAgICAgICAgICAubWF0Y2gocmV2aXRhbGl6ZXIpXG5cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnJlY29nbml6ZWQgcmV2aXRhbGl6YXRpb24gcmVnaXN0cmF0aW9uYClcblxuICByZWdpc3RlclJldml2ZXIoZW50cnkpIDo6XG4gICAgOjpcbiAgICAgIGNvbnN0IGtpbmQgPSBlbnRyeS5raW5kXG4gICAgICBpZiAnc3RyaW5nJyAhPT0gdHlwZW9mIGtpbmQgJiYgdHJ1ZSAhPT0ga2luZCAmJiBmYWxzZSAhPT0ga2luZCAmJiBudWxsICE9PSBraW5kIDo6XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IgQCBgXCJraW5kXCIgbXVzdCBiZSBhIHN0cmluZ2BcblxuICAgICAgaWYgZW50cnkuaW5pdCAmJiAnZnVuY3Rpb24nICE9PSB0eXBlb2YgZW50cnkuaW5pdCA6OlxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yIEAgJ1wiaW5pdFwiIG11c3QgYmUgYSBmdW5jdGlvbidcblxuICAgICAgaWYgJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGVudHJ5LnJldml2ZSA6OlxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yIEAgJ1wicmV2aXZlXCIgbXVzdCBiZSBhIGZ1bmN0aW9uJ1xuXG4gICAgICBpZiBlbnRyeS5wcmVzZXJ2ZSAmJiAnZnVuY3Rpb24nICE9PSB0eXBlb2YgZW50cnkucHJlc2VydmUgOjpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciBAICdcInByZXNlcnZlXCIgbXVzdCBiZSBhIGZ1bmN0aW9uIGlmIHByb3ZpZGVkJ1xuXG4gICAgcmV0dXJuIHRoaXMuX3NldFJldml2ZXIoZW50cnkpXG5cbiAgcmVnaXN0ZXJDbGFzcyhraW5kLCBrbGFzcykgOjpcbiAgICByZXR1cm4gdGhpc1xuICAgICAgLnJlZ2lzdGVyUmV2aXZlciBAOiBraW5kLFxuICAgICAgICByZXZpdmUob2JqLCBlbnRyeSkgOjpcbiAgICAgICAgICBvYmogPSBPYmplY3QuYXNzaWduKG9iaiwgZW50cnkuYm9keSlcbiAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yob2JqLCBrbGFzcy5wcm90b3R5cGUpXG4gICAgICAubWF0Y2goa2xhc3MsIGtsYXNzLnByb3RvdHlwZSlcblxuICByZWdpc3RlclByb3RvKGtpbmQsIHByb3RvKSA6OlxuICAgIHJldHVybiB0aGlzXG4gICAgICAucmVnaXN0ZXJSZXZpdmVyIEA6IGtpbmQsXG4gICAgICAgIHJldml2ZShvYmosIGVudHJ5KSA6OlxuICAgICAgICAgIG9iaiA9IE9iamVjdC5hc3NpZ24ob2JqLCBlbnRyeS5ib2R5KVxuICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihvYmosIHByb3RvKVxuICAgICAgLm1hdGNoKHByb3RvKVxuXG5cbiAgZGVjb2RlKGFTdHJpbmcsIGN0eCkgOjpcbiAgICBpZiBudWxsID09PSBhU3RyaW5nIDo6XG4gICAgICByZXR1cm4gbnVsbCAvLyBKU09OLnBhcnNlKG51bGwpIHJldHVybnMgbnVsbDsga2VlcCB3aXRoIGNvbnZlbnRpb25cblxuICAgIGlmIG51bGwgPT0gY3R4IDo6IGN0eCA9IHt9XG4gICAgY29uc3QgdG9rZW49dGhpcy50b2tlbiwgbG9va3VwUmV2aXZlcj10aGlzLmxvb2t1cFJldml2ZXJcblxuICAgIGNvbnN0IHF1ZXVlPVtdLCBieU9pZD1uZXcgTWFwKClcbiAgICBKU09OLnBhcnNlKGFTdHJpbmcsIF9qc29uX2NyZWF0ZSlcblxuICAgIGNvbnN0IHJlZnM9bmV3IE9iak1hcCgpXG4gICAgSlNPTi5wYXJzZShhU3RyaW5nLCBfanNvbl9yZXN0b3JlKVxuXG4gICAgY29uc3QgZXZ0cyA9IHt9XG4gICAgY29uc3QgX3N0YXJ0ID0gUHJvbWlzZS5yZXNvbHZlKCkudGhlbiBAICgpID0+XG4gICAgICBxdWV1ZS5yZXZlcnNlKCkubWFwIEAgZW50cnkgPT4gOjpcbiAgICAgICAgZW50cnkuZXZ0cyA9IGV2dHNcbiAgICAgICAgcmV0dXJuIGVudHJ5LnJldml2ZXIucmV2aXZlKGVudHJ5Lm9iaiwgZW50cnksIGN0eClcblxuICAgIGV2dHMuc3RhcnRlZCA9IF9zdGFydC50aGVuIEAgbHN0ID0+IGxzdC5sZW5ndGhcbiAgICBldnRzLmZpbmlzaGVkID0gX3N0YXJ0LnRoZW4gQCBsc3QgPT5cbiAgICAgIFByb21pc2UuYWxsKGxzdCkudGhlbiBAIGxzdCA9PiBsc3QubGVuZ3RoXG5cbiAgICBldnRzLmRvbmUgPSBldnRzLmZpbmlzaGVkLnRoZW4gQCAoKSA9PiA6OlxuICAgICAgY29uc3Qgcm9vdCA9IGJ5T2lkLmdldCgwKVxuICAgICAgaWYgbnVsbCA9PSByb290IDo6IHJldHVyblxuXG4gICAgICBjb25zdCB7b2JqLCBwcm9taXNlfSA9IHJvb3RcbiAgICAgIHJldHVybiB1bmRlZmluZWQgPT09IHByb21pc2UgPyBvYmpcbiAgICAgICAgOiBwcm9taXNlLnRoZW4gQCBhbnMgPT5cbiAgICAgICAgICAgIGFucyAhPT0gdW5kZWZpbmVkID8gYW5zIDogb2JqXG4gICAgcmV0dXJuIGV2dHMuZG9uZVxuXG5cbiAgICBmdW5jdGlvbiBfanNvbl9jcmVhdGUoa2V5LCB2YWx1ZSkgOjpcbiAgICAgIGlmIHRva2VuID09PSBrZXkgOjpcbiAgICAgICAgaWYgJ251bWJlcicgPT09IHR5cGVvZiB2YWx1ZSA6OlxuICAgICAgICBlbHNlIGlmIEFycmF5LmlzQXJyYXkodmFsdWUpIDo6XG4gICAgICAgICAgZGVsZXRlIHRoaXNbdG9rZW5dXG5cbiAgICAgICAgICBjb25zdCBba2luZCwgb2lkXSA9IHZhbHVlXG4gICAgICAgICAgY29uc3QgcmV2aXZlciA9IGxvb2t1cFJldml2ZXIoa2luZClcbiAgICAgICAgICBpZiB1bmRlZmluZWQgPT09IHJldml2ZXIgOjpcbiAgICAgICAgICAgIHRocm93IG5ldyBSZXZpdmVyTm90Rm91bmQoYE1pc3NpbmcgcmVnaXN0ZXJlZCByZXZpdmVyIGZvciBraW5kIFwiJHtraW5kfVwiYClcblxuICAgICAgICAgIGNvbnN0IGVudHJ5ID0gQDoga2luZCwgb2lkLCByZXZpdmVyLCBib2R5OiB0aGlzXG5cbiAgICAgICAgICBlbnRyeS5vYmogPSByZXZpdmVyLmluaXRcbiAgICAgICAgICAgID8gcmV2aXZlci5pbml0KGVudHJ5LCBjdHgpXG4gICAgICAgICAgICA6IE9iamVjdC5jcmVhdGUobnVsbClcblxuICAgICAgICAgIGJ5T2lkLnNldChvaWQsIGVudHJ5KVxuICAgICAgICAgIHF1ZXVlLnB1c2goZW50cnkpXG4gICAgICAgIHJldHVyblxuXG4gICAgICByZXR1cm4gdmFsdWVcblxuXG4gICAgZnVuY3Rpb24gX2pzb25fcmVzdG9yZShrZXksIHZhbHVlKSA6OlxuICAgICAgaWYgdG9rZW4gPT09IGtleSA6OlxuICAgICAgICBpZiAnbnVtYmVyJyA9PT0gdHlwZW9mIHZhbHVlIDo6XG4gICAgICAgICAgcmVmcy5zZXQgQCB0aGlzLCBieU9pZC5nZXQodmFsdWUpLm9ialxuXG4gICAgICAgIGVsc2UgaWYgQXJyYXkuaXNBcnJheSh2YWx1ZSkgOjpcbiAgICAgICAgICBjb25zdCBlbnRyeSA9IGJ5T2lkLmdldCh2YWx1ZVsxXSlcbiAgICAgICAgICBlbnRyeS5ib2R5ID0gdGhpc1xuICAgICAgICAgIHJlZnMuc2V0IEAgdGhpcywgZW50cnkub2JqXG4gICAgICAgIHJldHVyblxuXG4gICAgICBlbHNlIGlmIG51bGwgPT09IHZhbHVlIHx8ICdvYmplY3QnICE9PSB0eXBlb2YgdmFsdWUgOjpcbiAgICAgICAgcmV0dXJuIHZhbHVlXG5cbiAgICAgIGNvbnN0IGFucyA9IHJlZnMuZ2V0KHZhbHVlKVxuICAgICAgcmV0dXJuIGFucyAhPT0gdW5kZWZpbmVkID8gYW5zIDogdmFsdWVcblxuXG4gIGVuY29kZShhbk9iamVjdCwgY3R4KSA6OlxuICAgIGNvbnN0IHJlZnMgPSBbXVxuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLmVuY29kZU9iamVjdHMgQCBhbk9iamVjdCwgY3R4LCAoZXJyLCBlbnRyeSkgPT4gOjpcbiAgICAgIHJlZnNbZW50cnkub2lkXSA9IGVudHJ5LmNvbnRlbnRcblxuICAgIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5IEAgYCR7dGhpcy50b2tlbn1yZWZzYFxuICAgIHJldHVybiBwcm9taXNlLnRoZW4gQCAoKSA9PlxuICAgICAgYHske2tleX06IFtcXG4gICR7cmVmcy5qb2luKCcsXFxuICAnKX0gXX1cXG5gXG5cblxuICBlbmNvZGVPYmplY3RzKGFuT2JqZWN0LCBjdHgsIGNhbGxiYWNrKSA6OlxuICAgIGlmICdmdW5jdGlvbicgPT09IHR5cGVvZiBjdHggOjpcbiAgICAgIGNhbGxiYWNrID0gY3R4OyBjdHggPSB7fVxuICAgIGVsc2UgaWYgbnVsbCA9PSBjdHggOjpcbiAgICAgIGN0eCA9IHt9XG5cbiAgICBjb25zdCB0b2tlbj10aGlzLnRva2VuLCBsb29rdXBQcmVzZXJ2ZXI9dGhpcy5sb29rdXBQcmVzZXJ2ZXIsIGZpbmRQcmVzZXJ2ZXI9dGhpcy5fYm91bmRGaW5kUHJlc2VydmVGb3JPYmooKVxuXG4gICAgY29uc3QgcXVldWU9W10sIGxvb2t1cD1uZXcgTWFwKClcbiAgICBKU09OLnN0cmluZ2lmeShhbk9iamVjdCwgX2pzb25fcmVwbGFjZXIpXG5cbiAgICByZXR1cm4gX2VuY29kZVF1ZXVlKClcblxuICAgIGZ1bmN0aW9uIF9lbmNvZGVRdWV1ZSgpIDo6XG4gICAgICBpZiAwID09PSBxdWV1ZS5sZW5ndGggOjpcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cbiAgICAgIGNvbnN0IHByb21pc2VzID0gW11cbiAgICAgIHdoaWxlIDAgIT09IHF1ZXVlLmxlbmd0aCA6OlxuICAgICAgICBjb25zdCB0aXAgPSBxdWV1ZS5zaGlmdCgpLCBvaWQgPSB0aXAub2lkXG4gICAgICAgIHByb21pc2VzLnB1c2ggQFxuICAgICAgICAgIHRpcFxuICAgICAgICAgICAgLnRoZW4gQCBib2R5ID0+IDo6XG4gICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShib2R5LCBfanNvbl9yZXBsYWNlcilcbiAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrIEAgbnVsbCwgeyBvaWQsIGJvZHksIGNvbnRlbnQgfVxuICAgICAgICAgICAgLmNhdGNoIEAgZXJyID0+IGNhbGxiYWNrKGVycilcblxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKF9lbmNvZGVRdWV1ZSlcblxuICAgIGZ1bmN0aW9uIF9qc29uX3JlcGxhY2VyKGtleSwgZHN0VmFsdWUpIDo6XG4gICAgICAvLyBzcmNWYWx1ZSAhPT0gZHN0VmFsdWUgZm9yIG9iamVjdHMgd2l0aCAudG9KU09OKCkgbWV0aG9kc1xuICAgICAgY29uc3Qgc3JjVmFsdWUgPSB0aGlzW2tleV1cblxuICAgICAgaWYgZHN0VmFsdWUgPT09IG51bGwgfHwgJ29iamVjdCcgIT09IHR5cGVvZiBzcmNWYWx1ZSA6OlxuICAgICAgICByZXR1cm4gZHN0VmFsdWVcblxuICAgICAgY29uc3QgcHJldiA9IGxvb2t1cC5nZXQoc3JjVmFsdWUpXG4gICAgICBpZiB1bmRlZmluZWQgIT09IHByZXYgOjpcbiAgICAgICAgcmV0dXJuIHByZXYgLy8gYWxyZWFkeSBzZXJpYWxpemVkIC0tIHJlZmVyZW5jZSBleGlzdGluZyBpdGVtXG5cbiAgICAgIGxldCBlbnRyeSA9IGZpbmRQcmVzZXJ2ZXIoc3JjVmFsdWUpXG4gICAgICBpZiB1bmRlZmluZWQgPT09IGVudHJ5IDo6XG4gICAgICAgIC8vIG5vdCBhIFwic3BlY2lhbFwiIHByZXNlcnZlZCBpdGVtXG4gICAgICAgIGlmIGFuT2JqZWN0ICE9PSBzcmNWYWx1ZSA6OlxuICAgICAgICAgIHJldHVybiBkc3RWYWx1ZSAvLyBzbyBzZXJpYWxpemUgbm9ybWFsbHlcbiAgICAgICAgLy8gYnV0IGl0IGlzIHRoZSByb290LCBzbyBzdG9yZSBhdCBvaWQgMFxuICAgICAgICBlbnRyeSA9IGxvb2t1cFByZXNlcnZlciBAXG4gICAgICAgICAgQXJyYXkuaXNBcnJheShkc3RWYWx1ZSkgPyByb290X2xpc3QgOiByb290X29ialxuXG4gICAgICAvLyByZWdpc3RlciBpZCBmb3Igb2JqZWN0IGFuZCByZXR1cm4gYSBKU09OIHNlcmlhbGl6YWJsZSB2ZXJzaW9uXG4gICAgICBjb25zdCBvaWQgPSBsb29rdXAuc2l6ZVxuICAgICAgY29uc3QgcmVmID0ge1t0b2tlbl06IG9pZH1cbiAgICAgIGxvb2t1cC5zZXQoc3JjVmFsdWUsIHJlZilcblxuICAgICAgLy8gdHJhbnNmb3JtIGxpdmUgb2JqZWN0IGludG8gcHJlc2VydmVkIGZvcm1cbiAgICAgIGNvbnN0IGJvZHkgPSB7W3Rva2VuXTogW2VudHJ5LmtpbmQsIG9pZF19XG4gICAgICBjb25zdCBwcm9taXNlID0gUHJvbWlzZVxuICAgICAgICAucmVzb2x2ZSBAIGVudHJ5LnByZXNlcnZlID8gZW50cnkucHJlc2VydmUoZHN0VmFsdWUsIHNyY1ZhbHVlLCBjdHgpIDogZHN0VmFsdWVcbiAgICAgICAgLnRoZW4gQCBhdHRycyA9PiBPYmplY3QuYXNzaWduKGJvZHksIGF0dHJzKVxuXG4gICAgICBwcm9taXNlLm9pZCA9IG9pZFxuICAgICAgcXVldWUucHVzaCBAIHByb21pc2VcbiAgICAgIHJldHVybiByZWZcblxuICBfYm91bmRGaW5kUHJlc2VydmVGb3JPYmooKSA6OlxuICAgIGNvbnN0IGxvb2t1cFByZXNlcnZlciA9IHRoaXMubG9va3VwUHJlc2VydmVyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikgOjpcbiAgICAgIGxldCBlbnRyeSA9IGxvb2t1cFByZXNlcnZlcihvYmopXG4gICAgICBpZiB1bmRlZmluZWQgIT09IGVudHJ5IDo6XG4gICAgICAgIHJldHVybiBlbnRyeVxuXG4gICAgICBlbnRyeSA9IGxvb2t1cFByZXNlcnZlcihvYmouY29uc3RydWN0b3IpXG4gICAgICBpZiB1bmRlZmluZWQgIT09IGVudHJ5IDo6XG4gICAgICAgIHJldHVybiBlbnRyeVxuXG4gICAgICBsZXQgcHJvdG8gPSBvYmpcbiAgICAgIHdoaWxlIG51bGwgIT09IEAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pIDo6XG4gICAgICAgIGxldCBlbnRyeSA9IGxvb2t1cFByZXNlcnZlcihwcm90bylcbiAgICAgICAgaWYgdW5kZWZpbmVkICE9PSBlbnRyeSA6OlxuICAgICAgICAgIHJldHVybiBlbnRyeVxuXG5cbmNsYXNzIFJldml2ZXJOb3RGb3VuZCBleHRlbmRzIEVycm9yIDo6XG5cbmNvbnN0IGNyZWF0ZVJlZ2lzdHJ5ID0gUmV2aXRhbGl6YXRpb24uY3JlYXRlLmJpbmQoUmV2aXRhbGl6YXRpb24pXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGNyZWF0ZVJlZ2lzdHJ5KClcbk9iamVjdC5hc3NpZ24gQCBleHBvcnRzXG4gICwgQHt9IFJldml0YWxpemF0aW9uLCBSZXZpdmVyTm90Rm91bmRcbiAgICAgICwgY3JlYXRlUmVnaXN0cnksIGNyZWF0ZTogY3JlYXRlUmVnaXN0cnlcbiJdfQ==